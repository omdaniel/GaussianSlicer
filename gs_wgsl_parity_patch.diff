diff --git a/crates/slicer_core/src/gmm.rs b/crates/slicer_core/src/gmm.rs
index 0000000..1111111 100644
--- a/crates/slicer_core/src/gmm.rs
+++ b/crates/slicer_core/src/gmm.rs
@@ -1,3 +1,92 @@
+//! Aligned Gaussian3D definition to match WGSL 16-byte column alignment (80-byte stride).
+//! This replaces any previously "packed" 52-byte layout.
+//!
+//! - mean:      vec3<f32>  (16 bytes with pad)
+//! - covariance mat3x3<f32> as 3 padded columns (3 * 16 = 48 bytes)
+//! - weight:    f32        (4 bytes)
+//! - struct pad            (12 bytes)
+//! Total: 80 bytes
+
+use glam::{Mat3, Vec3, Vec3A};
+use bytemuck::{Pod, Zeroable};
+
+#[repr(C)]
+#[derive(Copy, Clone, Debug, Pod, Zeroable)]
+pub struct Gaussian3D {
+    /// Mean in world space; 16B aligned (xyz + pad)
+    pub mean: Vec3A,               // 16 B
+    /// Covariance matrix columns (world space), each 16B aligned
+    pub covariance_cols: [Vec3A; 3], // 48 B
+    /// Weight (mixture component weight / density scale)
+    pub weight: f32,               // 4 B
+    /// Padding to reach 80B stride (WGSL std layout)

+    _pad: [u32; 3],                // 12 B
+}
+
+// Enforce exact size to avoid accidental layout regressions.
+const _: () = assert!(::core::mem::size_of::<Gaussian3D>() == 80);
+
+impl Gaussian3D {
+    #[inline]
+    pub fn new(mean: Vec3, cov: Mat3, weight: f32) -> Self {
+        Self {
+            mean: mean.into(),
+            covariance_cols: [
+                cov.x_axis.into(), // column 0
+                cov.y_axis.into(), // column 1
+                cov.z_axis.into(), // column 2
+            ],
+            weight,
+            _pad: [0; 3],
+        }
+    }
+
+    #[inline]
+    pub fn covariance_mat3(&self) -> Mat3 {
+        // Reconstruct Mat3 from column vectors (xyz in each Vec3A)
+        Mat3::from_cols(
+            self.covariance_cols[0].into(),
+            self.covariance_cols[1].into(),
+            self.covariance_cols[2].into(),
+        )
+    }
+}
+
diff --git a/crates/slicer_shaders/shaders/precalculate.wgsl b/crates/slicer_shaders/shaders/precalculate.wgsl
index 2222222..3333333 100644
--- a/crates/slicer_shaders/shaders/precalculate.wgsl
+++ b/crates/slicer_shaders/shaders/precalculate.wgsl
@@ -1,3 +1,122 @@
+// K1: Precalculate — project mean & covariance into slice basis with explicit matrices.
+// This version eliminates row/column confusion by computing W2S = transpose(S2W)
+// and then Σ' = W2S * Σ * W2S^T. It assumes the host provides the rotation matrix
+// in padded column form in `config.rotation_matrix_cols` (array<vec4<f32>,4>).
+
+struct Gaussian3D {
+  mean: vec3<f32>;           // +4B implicit pad
+  covariance: mat3x3<f32>;   // 3 columns, 16B aligned each (48B)
+  weight: f32;               // +12B pad
+};
+
+struct KernelConfig {
+  // ... other fields ...
+  rotation_matrix_cols: array<vec4<f32>, 4>;
+  plane_offset: f32;
+  // ... other fields ...
+};
+
+@group(0) @binding(0) var<storage, read> gaussians: array<Gaussian3D>;
+@group(0) @binding(1) var<uniform> config: KernelConfig;
+@group(0) @binding(2) var<storage, read_write> k1_out: array<vec4<f32>>; // example layout for debug
+
+fn slice_to_world_from_config(cols: array<vec4<f32>, 4>) -> mat3x3<f32> {
+  let c0 = cols[0].xyz;
+  let c1 = cols[1].xyz;
+  let c2 = cols[2].xyz;
+  return mat3x3<f32>(c0, c1, c2); // column-major constructor
+}
+
+@compute @workgroup_size(64)
+fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
+  let idx = gid.x;
+  if (idx >= arrayLength(&gaussians)) { return; }
+
+  // Basis setup
+  let S2W : mat3x3<f32> = slice_to_world_from_config(config.rotation_matrix_cols);
+  let W2S : mat3x3<f32> = transpose(S2W);
+
+  // Load gaussian
+  let g = gaussians[idx];
+  let mu_world  : vec3<f32>   = g.mean;
+  let cov_world : mat3x3<f32> = g.covariance;
+
+  // Project mean & covariance into slice basis
+  let mu_slice  : vec3<f32>   = W2S * mu_world;
+  let cov_slice : mat3x3<f32> = W2S * cov_world * transpose(W2S);
+
+  // Optional: write debug output (pack first column of cov + mu)
+  // Adjust to your actual K1 output layout.
+  k1_out[idx * 2u + 0u] = vec4<f32>(cov_slice[0], mu_slice.x);
+  k1_out[idx * 2u + 1u] = vec4<f32>(cov_slice[1], mu_slice.y);
+  // (third column & mu_slice.z can be dumped to a third slot if needed)
+}
+
diff --git a/crates/slicer_shaders/shaders/update_params.wgsl b/crates/slicer_shaders/shaders/update_params.wgsl
index 4444444..5555555 100644
--- a/crates/slicer_shaders/shaders/update_params.wgsl
+++ b/crates/slicer_shaders/shaders/update_params.wgsl
@@ -1,3 +1,151 @@
+// K2: Update/Condition parameters using robust Schur complement with eps gating.
+// Consumes the K1-projected mean/covariance (slice basis).
+
+struct KernelConfig {
+  // ... other fields ...
+  rotation_matrix_cols: array<vec4<f32>, 4>;
+  plane_offset: f32;
+  // ... other fields ...
+};
+
+struct K1Out {
+  // Example layout: packed mu_slice + cov_slice columns (adjust to your actual buffers)
+  mu_slice: vec3<f32>;
+  _pad0: f32;
+  cov_col0: vec3<f32>; _pad1: f32;
+  cov_col1: vec3<f32>; _pad2: f32;
+  cov_col2: vec3<f32>; _pad3: f32;
+};
+
+struct K2Out {
+  mu_cond: vec2<f32>;
+  _pad0: vec2<f32>;
+  acond_col0: vec2<f32>; _pad1: vec2<f32>;
+  acond_col1: vec2<f32>; _pad2: vec2<f32>;
+};
+
+@group(0) @binding(0) var<uniform> config: KernelConfig;
+@group(0) @binding(1) var<storage, read>  k1_in: array<K1Out>;
+@group(0) @binding(2) var<storage, read_write> k2_out: array<K2Out>;
+
+fn slice_to_world_from_config(cols: array<vec4<f32>, 4>) -> mat3x3<f32> {
+  let c0 = cols[0].xyz;
+  let c1 = cols[1].xyz;
+  let c2 = cols[2].xyz;
+  return mat3x3<f32>(c0, c1, c2);
+}
+
+@compute @workgroup_size(64)
+fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
+  let idx = gid.x;
+  if (idx >= arrayLength(&k1_in)) { return; }
+
+  // Recompute basis (if needed by other terms); not strictly required here,
+  // but kept for symmetry with K1 and for any per-frame plane calculations.
+  let S2W : mat3x3<f32> = slice_to_world_from_config(config.rotation_matrix_cols);
+  let W2S : mat3x3<f32> = transpose(S2W);
+  _ = W2S; // silence unused if not needed
+
+  let k1 = k1_in[idx];
+  let mu_slice  = k1.mu_slice;
+  let cov_slice = mat3x3<f32>(k1.cov_col0, k1.cov_col1, k1.cov_col2);
+
+  // Partition Σ' into blocks: A(2x2), b(2x1), c(1x1)
+  // Note: WGSL is column-major. M[c][r]
+  let a00 = cov_slice[0][0];
+  let a01 = cov_slice[1][0];
+  let a10 = cov_slice[0][1];
+  let a11 = cov_slice[1][1];
+  let A   = mat2x2<f32>(a00, a10, a01, a11); // columns
+
+  let b   = vec2<f32>(cov_slice[2][0], cov_slice[2][1]);
+  let c   = cov_slice[2][2];
+
+  // Plane distance along the slice normal coordinate
+  let delta_n = (mu_slice.z - config.plane_offset);
+
+  // Robust inversion gate
+  let eps   = 1e-6;
+  let inv_c = select(1.0 / c, 0.0, c <= eps);
+
+  // Conditional mean and covariance
+  let mu_u   = mu_slice.xy;
+  let mu_cond = mu_u - b * inv_c * delta_n;
+  let A_cond  = A    - outerProduct(b, b) * inv_c;
+
+  // Write results
+  var o: K2Out;
+  o.mu_cond = mu_cond;
+  o.acond_col0 = vec2<f32>(A_cond[0][0], A_cond[0][1]);
+  o.acond_col1 = vec2<f32>(A_cond[1][0], A_cond[1][1]);
+  k2_out[idx] = o;
+}
+
diff --git a/Sources/MetalApp/MetalRenderer.swift b/Sources/MetalApp/MetalRenderer.swift
index 6666666..7777777 100644
--- a/Sources/MetalApp/MetalRenderer.swift
+++ b/Sources/MetalApp/MetalRenderer.swift
@@ -1,3 +1,78 @@
+// DEBUG readback instrumentation for Metal to dump K1/K2 outputs.
+// Note: wrap these changes with a build flag if you prefer (e.g., #if DEBUG).
+
+import Foundation
+import Metal
+
+// ... within your renderer class ...
+
+func makeBuffersForDebug(precalcSize: Int, dynamicSize: Int) {
+    // Previously these may have been .storageModePrivate; switch to .shared for CPU readback
+    self.precalcBuffer = device.makeBuffer(length: precalcSize, options: .storageModeShared)
+    self.dynamicBuffer = device.makeBuffer(length: dynamicSize, options: .storageModeShared)
+}
+
+func runInitialPrecalculationAndDump() {
+    guard let commandBuffer = commandQueue.makeCommandBuffer() else { return }
+    // encode K1 into commandBuffer targeting precalcBuffer...
+
+    commandBuffer.commit()
+    commandBuffer.waitUntilCompleted()
+
+    // Dump K1 (precalc) buffer
+    if let buf = self.precalcBuffer {
+        let ptr = buf.contents()
+        let data = Data(bytes: ptr, count: buf.length)
+        let url = URL(fileURLWithPath: "/tmp/metal_k1_precalc.raw")
+        try? data.write(to: url)
+        print("Wrote \(buf.length) bytes to \(url.path)")
+    }
+}
+
+func runDynamicUpdateAndDump() {
+    guard let commandBuffer = commandQueue.makeCommandBuffer() else { return }
+    // encode K2 into commandBuffer targeting dynamicBuffer...
+
+    commandBuffer.commit()
+    commandBuffer.waitUntilCompleted()
+
+    // Dump K2 (dynamic) buffer
+    if let buf = self.dynamicBuffer {
+        let ptr = buf.contents()
+        let data = Data(bytes: ptr, count: buf.length)
+        let url = URL(fileURLWithPath: "/tmp/metal_k2_dynamic.raw")
+        try? data.write(to: url)
+        print("Wrote \(buf.length) bytes to \(url.path)")
+    }
+}
+
+// For K3, read back the density texture by blitting into a shared buffer (example):
+func dumpDensityTexture(texture: MTLTexture) {
+    let bytesPerPixel = 4 // r32float -> 4 bytes
+    let rowBytes = texture.width * bytesPerPixel
+    let size = rowBytes * texture.height
+    guard let buffer = device.makeBuffer(length: size, options: .storageModeShared) else { return }
+
+    guard let blit = commandQueue.makeCommandBuffer(),
+          let blitter = blit.makeBlitCommandEncoder() else { return }
+
+    let region = MTLRegionMake2D(0, 0, texture.width, texture.height)
+    blitter.copy(from: texture,
+                 sourceSlice: 0,
+                 sourceLevel: 0,
+                 sourceOrigin: region.origin,
+                 sourceSize: region.size,
+                 to: buffer,
+                 destinationOffset: 0,
+                 destinationBytesPerRow: rowBytes,
+                 destinationBytesPerImage: size)
+    blitter.endEncoding()
+    blit.commit()
+    blit.waitUntilCompleted()
+
+    let data = Data(bytes: buffer.contents(), count: size)
+    try? data.write(to: URL(fileURLWithPath: "/tmp/metal_k3_density.raw"))
+    print("Wrote \(size) bytes to /tmp/metal_k3_density.raw")
+}
+
